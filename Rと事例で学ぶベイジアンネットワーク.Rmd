---
title: "Rと事例で学ぶベイジアンネットワーク"
author: "Takaki Ohara"
output:
  pdf_document:
    latex_engine: xelatex 
    number_sections: true
---

```{r setup, include=FALSE}
# セットアップチャンク
library(knitr)
opts_knit$set(progress = FALSE) # 変換処理の際のプログレスバーを非表示に
opts_chunk$set(warning=FALSE, error=FALSE, message=FALSE)
options(tinytex.verbose = TRUE)
```

<https://www.bnlearn.com/book-crc-2ed/>

# 1.離散型データ事例

## 1.2グラフィカル表現

```{r}
library(bnlearn)
dag <- empty.graph(nodes=c("A","S","E","O","R","T"))
dag
```

```{r}
dag <- set.arc(dag, from="A", to="E")
dag <- set.arc(dag, from="S", to="E")

dag <- set.arc(dag, from="E", to="O")
dag <- set.arc(dag, from="E", to="R")

dag <- set.arc(dag, from="O", to="T")
dag <- set.arc(dag, from="R", to="T")

dag
```

関数の説明

```{r}
nodes(dag)
```

```{r}
arcs(dag)
```

まとめてアークを追加することも可能

```{r}
dag2 <- empty.graph(nodes = c("A","S","E","O","R","T"))
arc.set <- matrix(c("A","E",
                    "S","E",
                    "E","O",
                    "E","R",
                    "O","T",
                    "R","T"),
                  byrow =TRUE, ncol = 2,
                  dimnames = list(NULL, c("from", "to")))
arcs(dag2) <- arc.set
dag2
```

```{r}
#同一か確認
all.equal(dag,dag2)
```

```{r}
#循環している場合エラーがでる
#set.arc(dag, from = "T", to = "E")
```

## 1.3確率的表現

BNを作成するに当たり変数に同時確率分布を導入する必要あり

すべて離散型データなのでRにおいて水準(level)という非連続状態のデータセットを定義する必要あり

```{r}
A.lv <-c("young","adult","old")
S.lv <-c("M","F")
E.lv <-c("high","uni")
O.lv <-c("emp","self")
R.lv <-c("small","big")
T.lv <-c("car","train","other")
```

```{r}
A.prob <-array(c(0.30,0.50,0.20), dim=3, dimnames = list(A = A.lv))
A.prob
```

```{r}
S.prob <-array(c(0.60,0.40), dim=2, dimnames = list(S = S.lv))
S.prob
```

```{r}
O.prob <-matrix(c(0.96,0.04,0.92,0.08), ncol = 2, dimnames = list(O=O.lv, E=E.lv))
O.prob
```

```{r}
R.prob <-matrix(c(0.25,0.75,0.20,0.80), ncol = 2, dimnames = list(R=R.lv, E=E.lv))
R.prob
```

```{r}
E.prob <-array(c(0.75,0.25,0.72,0.28,0.88,0.12,0.64,0.36,0.70,0.30,0.90,0.10), dim = c(2,3,2), dimnames = list(E=E.lv, A=A.lv, S=S.lv))
E.prob
```

```{r}
T.prob <-array(c(0.48,0.42,0.10,0.56,0.36,0.08,0.58,0.24,0.18,0.70,0.21,0.09), dim = c(3,2,2), dimnames = list(T=T.lv, O=O.lv, R=R.lv))
T.prob
```

上記の条件付き確率表とDAGを組み合わせる必要あり

```{r}
#以下のように直接ネットワークを記述することも可能
dag3 <- model2network("[A][S][E|A:S][O|E][R|E][T|O:R]")
```

```{r}
#cptは条件付き確率表を意味する
cpt <- list(A = A.prob, S = S.prob, E = E.prob, O = O.prob, R = R.prob, T= T.prob)
bn <- custom.fit(dag, cpt)
```

```{r}
#パラメータ数確認
nparams(bn)
```

```{r}
#arc確認
arcs(bn)
```

```{r}
#条件付き確率表を示せる
bn$R
```

```{r}
#条件付き確率表部分のみを出せる
coef(bn$R)
```

```{r}
#全体を示す
bn
```

## 1.4パラメータの推定：条件付き確率表

```{r}
survey <- read.table("survey.txt", header = TRUE, colClasses = "factor")
```

パラメータ=局所的分布における条件付き確率そのもの

```{r}
#bn.fit関数を用いることでデータからパラメータ推定可能
#mleは最尤推定法を用いている
bn.mle <- bn.fit(dag, data = survey, method = "mle")

bn.mle$O
```

```{r}
#bayesにすると事後分布を用いたベイズ的方法になる
bn.bayes <- bn.fit(dag, data = survey, method = "bayes", iss = 10)
bn.bayes$O
```

iss (imaginary sample size)はオプション：事前分布にどの程度重み付けするか

小さい値（1-15）にするのが一般的、値が大きいと事後分布が一様になり事前分布として用いられた一様分布へと近似していく

ベイズのほうがより1から遠い値となる→0を含むセルが減る

最尤推定法よりもロバストで予測力の高いベイジアンネットワークを構築可能

## 1.5DAG構造の学習：検定とスコア

-   DAGの構造を探索していくこと自体が調査の目的の場合もある

-   どのノードが分析対象のノードと直接関連があるか特定可能

### 1.5.1条件付き独立性検定

個々のアークの有無に焦点を当てたもの

条件付き独立の帰無仮説（確率的に独立である）が棄却されるならそのアークをDAGの中に加えることができる

```{r}
#ci.test関数で対数尤度比検定、Χ2検定が可能
ci.test("T","E",c("O","R"),test = "mi", data = survey)
```

```{r}
ci.test("T","E",c("O","R"),test = "x2", data = survey)
```

いずれもp値が大きいため、E→Tの関連性で有意差なし→現在のDAG構造に加えるような関連性なし

```{r}
#まとめて検定を実施可能
arc.strength(dag, data = survey, criterion = "x2")
```

O→T以外のすべてのアークは支持されたものと判断可能

### 1.5.2ネットワークスコア

ネットワーク全体としてのDAGに焦点を当てている。

DAGがデータの依存構造をどの程度よく反映しているかの適合度指標

$$
BIC = \log\widehat{Pr}(A,S,E,O,R,T) - \frac{d}{2}\log n
$$

n：サンプルサイズ、d：ネットワーク全体のパラメータ数

DAGがデータにフィットしているほど高い値を示す

```{r}
#BIC
score(dag, data = survey, type = "bic")
```

```{r}
#対数BDe
score(dag, data = survey, type = "bde", iss = 10)
```

```{r}
#例としてランダムグラフを作ってみるとさすがにスコアが悪い
rnd <- random.graph(nodes = c("A","S","E","O","R","T"))
modelstring(rnd)
score(rnd, data = survey, type = "bic")
```

ネットワークのスコアが最大となるDAGを探索するためのアルゴリズム

-   山登り法

    -   アークなしのDAGからスタートして1つひとつのアークを順次追加、除去、反転させることで最もネットワークスコアが増加する状況を探索する方法

    -   hcを使ったらデフォルトはbicで計算される

```{r}
learned <- hc(survey)
modelstring(learned)
```

```{r}
score(learned, data = survey, type = "bic")
```

```{r}
arc.strength(learned, data = survey, criterion = "bic")
```

## 1.6離散型データでベイジアンネットワークを使ってみよう

### 1.6.1DAG構造を使って

```{r}
dsep(dag, x = "S", y = "R")
```

教育水準(E)は性別(S)から影響を受けており、居住地(R)は教育水準(E)から影響を受けている（S→E、E→R）ので

性別(S)と居住地(R)が関連することは明らか

教育水準(E)を条件付けると性別(S)と居住地(R)の間のパスをブロックすることになるので独立になる

```{r}
dsep(dag, x = "S", y = "R", z = "E")
```

$$
Pr(O,R|E) = Pr(O|E)Pr(R|E)
$$

### 1.6.2条件付き確率表を使って

#### 1.6.2.1厳密推論

```{r}
library(gRain)
```

ベイジアンネットワークを特別丹念に構築されたツリー構造に変換する方法に依拠している

ツリー構造に対して、compile関数で確率表を計算できる→setEvicence関数を用いてエビデンスをjunctionオブジェクトに入力する

例）「女性が自動車や電車を利用することに対する態度」を調査したい。男女のサンプルvs女性だけのサンプルで比較したい

```{r}
#全体サンプル
junction <- compile(as.grain(bn))
querygrain(junction, nodes = "T")$T
```

```{r}
#女性だけのサンプル
jsex <- setEvidence(junction, nodes = "S", states = "F")
querygrain(jsex, nodes = "T")$T
```

→好みは同程度であった

例2）小規模の都市に居住することで利用する交通手段がどうかわるか

```{r}
jres <- setEvidence(junction, nodes = "R", states = "small")
querygrain(jres, nodes = "T")$T
```

条件付き独立性を評価したい

例3）教育水準が与えられた場合の性別と交通手段の同時確率分布

```{r}
jedu <- setEvidence(junction, nodes = "E", states = "high")
SxT.cpt <- querygrain(jedu, nodes = c("S","T"), type = "conditional")
SxT.cpt
```

2番目のノードで条件付けられた場合の1番目のノードの分布を算出できた

交通手段(T)がどのような状態でも男性にかかる条件付き確率は同じ→教育水準Eのもとで性別Sと交通手段Tは独立

#### 1.6.2.2近似推論

ベイジアンネットワークを利用することで観測値をランダムに生成する方法（モンテカルロシミュレーション）

計算コストは高いが、多くのノードを含む大規模なBNを扱うことが可能

```{r}
#あるエビデンスを与えた場合の特定のイベントに関する確率を算出する
cpquery(bn, event = (S == "M") & (T == "car"), evidence = (E == "high"))
```

ただしquerygrain関数で出される正確な値とは多少異なる

```{r}
#nを増やせば多少改善はするが時間がかかる
cpquery(bn, event = (S == "M") & (T == "car"), evidence = (E == "high"), n = 10^6)
```

```{r}
#尤度重み付き方法を使えば真値に非常に近い確率で算出可能
cpquery(bn, event = (S == "M") & (T == "car"), evidence = list(E = "high"), method = "lw")
```

```{r}
#cpdist関数はエビデンスに適合するような変数のランダムな観測値を算出し、それを含んだdfを返す
SxT <- cpdist(bn, nodes = c("S", "T"), evidence = (E == "high"))
head(SxT)
```

## 1.7ベイジアンネットワークの図示

詳細は以下に記載あり

<https://www.bnlearn.com/examples/graphviz-plot/>

```{r}
graphviz.plot(dag)
```

```{r}
hlight <- list(nodes = nodes(dag), arcs = arcs(dag), col = "grey", textCol = "grey")
pp <- graphviz.plot(dag, highlight = hlight, render = FALSE)

library(Rgraphviz)
edgeRenderInfo(pp) <- list(col = c("S~E" ="black", "E~R" = "black"),
                           lwd = c("S~E" = 3, "E~R" = 3))
nodeRenderInfo(pp) <-
  list(col = c("S" = "black", "E" = "black", "R" = "black"),
       textCol = c("S" = "black", "E" = "black", "R" = "black"),
       fill = c("E" = "grey"))
renderGraph(pp)
```

### 1.7.2条件付き確率分布の図示

```{r}
bn.fit.barchart(bn.mle$T, main = "Travel", xlab = "Pr(T|R,O)", ylab ="")
```

交通手段の周辺確率と2つの条件付き確率クエリの結果を比較する

```{r}
Evidence <- factor(c(rep("Unconditional",3), rep("Female", 3),
                     rep("Small City",3)),
              levels = c("Unconditional", "Female", "Small City"))
Travel <- factor(rep(c("car", "train", "other"), 3),
            levels = c("other", "train", "car"))
distr <- data.frame(Evidence = Evidence, Travel = Travel,
           Prob = c(0.5618, 0.2808, 0.15730, 0.5620, 0.2806,
                    0.1573, 0.4838, 0.4170, 0.0990))
distr
```

```{r}
library(lattice)
barchart(Travel ~ Prob | Evidence, data = distr,
   layout = c(3, 1), xlab = "probability",
   scales = list(alternating = 1, tck = c(1, 0)),
   strip = strip.custom(factor.levels =
     c(expression(Pr(T)),
       expression(Pr({T} * " | " * {S == F})),
       expression(Pr({T} * " | " * {R == small})))),
   panel = function(...) {
     panel.barchart(...)
     panel.grid(h = 0, v = -1)
   })
```

仕様書

<https://www.bnlearn.com/documentation/man/graphviz.chart.html>

このあたりはグラフ描画がうまくいかないのでパス。そこまで重要でもないし

```{r}
library("Rgraphviz")
graphviz.chart(bn)
```

```{r}
graphviz.chart(as.bn.fit(jedu, including.evidence = TRUE), grid = TRUE,
    bar.col = c(A = "black", S = "black", E = "grey", O = "black",
                R = "black", T = "black"),
    strip.bg = c(A = "transparent", S = "transparent", E = "grey",
                 O = "transparent", R = "transparent", T = "transparent"),
    main = "BN with Evidence")
```

# 2.連続型データ事例：ガウシアン・ベイジアンネットワーク

## 2.1事例紹介

-   遺伝的ポテンシャル：genetic potential;G

-   環境的ポテンシャル：environmental potential;E

-   種子の数;N

-   種子の平均重量;W

-   栄養器官：単一の植物に蓄えられる栄養に関する情報すべてを統合した変数;V

-   目的変数：作物の収穫量;C

それぞれを1つの連続型変数として扱う

## 2.2グラフィカル表現

```{r}
library(bnlearn)
dag.bnlearn <- model2network("[G][E][V|G:E][N|V][W|V][C|N:W]")
dag.bnlearn
```

```{r}
graphviz.plot(dag.bnlearn)
```

```{r}
#どの変数の組み合わせが周辺的に独立しているか確認する
crop.nodes <- nodes(dag.bnlearn)
for(n1 in crop.nodes){
  for(n2 in crop.nodes){
    if(dsep(dag.bnlearn, n1, n2))
       cat(n1, "and", n2, "are independent.\n")
  }
}
```

EとGのみが独立している、独立性は対称的だった

```{r}
#変数をすべての組あわせで対にして、栄養器官(V)で条件づけられた場合にどのペアが条件付き独立となるか確認できる
for(n1 in crop.nodes[crop.nodes != "V"]){
  for(n2 in crop.nodes[crop.nodes != "V"]){
   if(n1<n2){
     if(dsep(dag.bnlearn, n1, n2, "V"))
       cat(n1, "and", n2, "are independent given V.\n")
   } 
  }
}
```

Vで条件づけられるとEとGは独立ではない

## 2.3確率的表現

```{r}
#各パラメータの確率分布を定義する
E.dist <- list(coef = c("(Intercept)" = 50), sd = 10)
G.dist <- list(coef = c("(Intercept)" = 50), sd = 10)
V.dist <- list(coef = c("(Intercept)" = -10.35534, E = 0.70711, G = 0.5), sd = 5)
N.dist <- list(coef = c("(Intercept)" = 45, V = 0.1), sd = 9.949874)
W.dist <- list(coef = c("(Intercept)" = 15, V = 0.7), sd = 7.141428)
C.dist <- list(coef = c("(Intercept)" = 0, N = 0.3, W = 0.7), sd = 6.25)
dist.list <- list(E = E.dist, G = G.dist, V = V.dist, N = N.dist, W = W.dist, C = C.dist)
```

```{r}
gbn.bnlearn <- custom.fit(dag.bnlearn, dist = dist.list)
```

```{r}
#局所分布のパラメータ
gbn.bnlearn$C
```

上記は線形ガウシアン・ベイジアンネットワークである

-   すべてのノードは正規分布に基づく

-   親のノードをもたないノードは周辺分布により記述

-   各ノードの分散はそのノードに特有で親ノードに依存しない

-   各ノードの局所的分布は切片と親ノードを含んだ線形ガウシアンモデルとして表現

```{r}
#ガウシアン・ベイジアンネットワークに特化したRパッケージ
library(rbmn)
#bn.fitオブジェクトを変換する
gbn.rbmn <- bnfit2nbn(gbn.bnlearn)
```

```{r}
#多変量正規分布のパラメータを得る
gema.rbmn <- nbn2gema(gbn.rbmn)
mn.rbmn <- gema2mn(gema.rbmn)
print8mn(mn.rbmn)
```

1列目：周辺分布の期待値

2列目：周辺分布の標準偏差

3列目以降：相関行列

## 2.4パラメータの推定：相関係数

DAG構造は既知とする

```{r}
#200の観測サンプルを生成して、cropdata200に格納する
set.seed(4567)
cropdata200 <- rbn(gbn.bnlearn, n = 200)
set.seed(1234)
cropdata20k <- rbn(gbn.bnlearn, n = 20000)
dim(cropdata200)
round(head(cropdata200), 2)
```

```{r}
#パラメータを推定する
#変数が因子型でなければ自動的にガウシアン・ベイジアンネットワークと判断される
crop.fitted <- bn.fit(dag.bnlearn, data = cropdata200)
crop.fitted
```

```{r}
#特定のノードについて異なるパラメータ推定法を用いることもできる
crop.fitted$C <- lm(C ~ N + W, data = cropdata200)
crop.fitted$C
```

一般的な回帰モデルをもちいてパラメータ推定を行う

リッジ、ラッソ回帰などについては以下を参照

<https://aizine.ai/ridge-lasso-elasticnet/>

```{r}
#収穫量Cについてリッジ回帰を当てはめてみる
library(penalized)
crop.fitted$C <- penalized(C ~ N + W, lambda1 = 0, lambda2 = 1.5, data = cropdata200)
```

推定した値を真値（avg:50, sd:10)と比較する

```{r}
crop.fitted$E
```

```{r}
crop.fitted$C
```

NやW、SDについては真値に近似しているが、切片が0とは遠いので以下で直接修正する

```{r}
crop.fitted$C <- lm(C ~ N + W - 1, data = cropdata200)
crop.fitted$C
```

## 2.5DAG構造の学習：検定とスコア

### 2.5.1条件付き独立性検定

```{r}
cormat <- cor(cropdata200[, c("C", "W", "N")])
cormat
```

```{r}
#cormat（相関行列）からinvcor(偏相関行列)を計算する
#ほかのすべての変数で条件づけられた場合のXとYにおける偏相関という意味
library(corpcor)
invcor <- cor2pcor(cormat)
dimnames(invcor) <- dimnames(cormat)
invcor
```

```{r}
#種子の数Nで条件づけられた場合に作物の収穫量Cと種子の平均重量Wは独立か、という仮説を検証できる
ci.test("C", "W", "N", test = "cor", data = cropdata200)
```

有意な偏相関があったことから帰無仮説を棄却し、独立でないと言える

```{r}
#200個のデータセットは大規模ではないので構造自体を学習させると以下のようになる
pdag1 <- iamb(cropdata200, test = "cor")
graphviz.plot(pdag1)
```

```{r}
#20kのデータセットを用いると正しく予測できる
pdag2 <- iamb(cropdata20k, test = "cor")
graphviz.plot(pdag2)
```

```{r}
#一部アークの追加、削除ができる
wl <- matrix(c("V", "N"), ncol = 2)
pdag3 <- iamb(cropdata200, test = "cor", whitelist = wl)
graphviz.plot(pdag3)
```
