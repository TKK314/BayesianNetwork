# 混合事例：条件付きガウシアン・ベイジアンネットワーク

## 事例紹介：健康管理にかかるコスト

| 項目名           | 型   | 略語 | 説明                                           |
|--------------|--------|-------|--------------------------------------------|
| 年齢             | 離散 | A    | young, adult, old                              |
| 既往歴           | 離散 | C    | none, mild, severe                             |
| 通院に係る支出   | 連続 | O    | 専門相談員のところに通院する際に係る個人の支出 |
| 入院に係る支出   | 連続 | I    | 入院全般にかかる個人の費用                     |
| 入院の有無       | 離散 | H    | any:数日過ごした, none:入院無し                |
| 入院日数         | 連続 | D    |                                                |
| 医療費に係る税金 | 連続 | T    | 医療費を支払う際にかかる税金                   |

```{r}

dag <- model2network("[A][C|A][H|A][D|A:H][I|C:D][O|A][T|O:I]")
graphviz.plot(dag)
```

```{r}
#Aの条件付き確率表作成
A.lv <- c("young", "adult", "old")
A.prob <- array(c(0.35, 0.45, 0.20), dim = 3, dimnames = list(A = A.lv))
A.prob
```

年齢に応じて既往症のレベルが異なるようにCを条件付ける

```{r}
C.lv <- c("none", "mild", "severe")
C.prob <- array(c(0.88, 0.10, 0.02, 0.75, 0.20, 0.05, 0.42, 0.53, 0.05),
                dim = c(3, 3), dimnames = list(C = C.lv, A = A.lv))
C.prob
```

```{r}
H.lv <- c("none", "any")
H.prob <- array(c(0.90, 0.10, 0.75, 0.25, 0.60, 0.40),
                dim = c(2, 3), dimnames = list(H = H.lv, A = A.lv))
H.prob
```

```{r}
D.coef <- list(coef = array(c(0, 0, 0, 1, 4, 7), dim = c(1, 6),
                            dimnames = list("(Intercept)", NULL)),
               sd = c(0, 0, 0, 0.5, 1, 1.5))
D.coef
```

DはH(入院の有無)×A(young mild old)に対応している

Hがnoneなら0

-   離散型変数→連続型変数の場合

    -   親ノードの離散型変数の値に応じて複数の線形回帰モデルをセットとして表現する

-   連続型変数が複数の離散型変数を親ノードとして持つ場合

    -   親ノードの値に対応した回帰モデルを複数含む形で構成される

-   連続型変数の親ノードが連続型変数である場合

    -   親ノードの連続型変数が子ノードの下位モデルに混在する形

```{r}
I.coef <- list(coef = array(c(1, 3, 1, 5.5, 1, 8) * 100 ,
                            dim = c(2, 3), dimnames = list(c("(Intercept)", "D"), NULL)) ,
               sd = c(30, 50, 100))
I.coef
```

```{r}
O.coef <- list(coef = array(c(60, 180, 360), dim = c(1, 3),
                            dimnames = list("(Intercept)", NULL)),
               sd = c(10, 20, 40))
T.coef <- list(coef = c("(Intercept)" = 120, I = 1.02, O = 1.05),
               sd = 10)
```

$$
T= 120+1.02I+1.05O+\varepsilon_T\sim N(0,10^2)
$$

上記内容でBNを定義したのでbn.fitオブジェクトを作成する

```{r}
dists <- list(A = A.prob, C= C.prob, H = H.prob, D= D.coef,
              I = I.coef, O = O.coef, "T" = T.coef)
healthcare <- custom.fit(dag, dists)
healthcare$I
```

上記で構築したものが、条件付きガウシアン・ベイジアンネットワーク（CGBN）である。

-   離散型ノードは多項分布に従う

-   連続型ノード（親ノードに離散型を含まない）は正規分布に従う

-   1つ以上の離散型ノードの親を持つ連続型ノードは、離散型変数である親の状態を組み合わせた中における1つの要素の混合正規分布に従う

-   混合状態における各要素は独立したパラメータを持つ

-   連続型ノードは連続型ノード、離散型ノードいずれも親にできる\
    離散型ノードは離散型ノードしか親にできない

## パラメータの推定：混合回帰

すでにDAGは既知であるとする

```{r}
costs <- read.table("data/healthcare.txt", header = TRUE,
                    colClasses = c("factor", "factor", "numeric", "factor",
                                   "numeric", "numeric", "numeric"))
```

```{r}
#最尤推定法で局所的分布のパラメータを推定した
fitted <- bn.fit(dag, data = costs)
```

```{r}
#今回推定したもの
coef(fitted$H)
```

離散型変数

```{r}
#経験的頻度を用いて推定したもの→つまり実際の値から算出される確率
cpt.H <- prop.table(table(costs[, c("H", "A")]), margin = 2)
#これをfitの推定値と比較してみる
all.equal(cpt.H, coef(fitted$H))
```

同じものが得られている

連続型変数は以下

```{r}
#lm関数による推定結果と同等となる
params.T <- lm(T~I+O, data = costs)
all.equal(coef(fitted$T), coef(params.T))
```

```{r}
#sigmaについても同様である
all.equal(sigma(fitted$T), sigma(params.T))
```

離散型の親ノードをもつ連続型のmodelの場合

```{r}
models.I <- list(lm(I~D, data = costs[costs$C == "none", ]),
                 lm(I~D, data = costs[costs$C == "mild", ]),
                 lm(I~D, data = costs[costs$C == "severe", ]))
matrix(c(coef(models.I[[1]]), coef(models.I[[2]]), coef(models.I[[3]])),
  nrow = 2, ncol = 3, dimnames = list(c("(Intercept)", "D"), 
                                        c("none", "mild", "severe")))
```

```{r}
c(none = sigma(models.I[[1]]), mild = sigma(models.I[[2]]),
  severe = sigma(models.I[[3]]))
```

```{r}
#以下と同じになる
fitted$I
```

<!--# なぜか0と1の場所が逆になっている -->
